import numpy as np
import pandas as pd
import math
import os, sys, glob, re
import csv
from optparse import OptionParser

def ParseInput(ArgsIn):
    UseMsg = '''
    Usage: python [script] [target_dir contains an output file generated by Q-Chem]
    '''
    parser = OptionParser(usage=UseMsg)
   
    options, args = parser.parse_args(ArgsIn)
    if len(args) < 2:
        parser.print_help()
        sys.exit(0)
    return options, args

def number_of_atoms(input_filename):
    count = 0
    start_counting = False
    with open(input_filename, 'r') as file:
        for line in file:
            if "$molecule" in line:
                start_counting = True
                continue
            if "$end" in line:
                break
            if start_counting and line.strip():
                count += 1
    num_atoms = count - 1
    return num_atoms
    

def parse_and_save_projected_hessian(input_filename, output_filename):
    num_of_atoms = number_of_atoms(input_filename)
    start_reading = False
    found_projected = False
    data_blocks = []
    current_block = []

    with open(input_filename, 'r') as file:
        for line in file:
            if "Projected Mass-Weighted Hessian Matrix:" in line:
                start_reading = True
                found_projected = True
                continue

            if "Vibrational Frequencies in atomic units" in line:
                break    

            if start_reading and line.strip():
                #each line has exactly 6 values (one row of a block)
                values = list(map(float, line.strip().split()))
                if len(values) == 6 or len(values) == 3:
                    data_blocks.append(values)
        
        if not found_projected:
            sys.exit("Projected Mass-Weighted Hessian matrix not found in the output.")

    number_of_coordinates = 3*num_of_atoms
    full_block = number_of_coordinates/6
    num_full_blocks = math.floor(full_block)
    num_columns_full_blocks = num_full_blocks * 6

    if full_block == num_full_blocks: #no half block
        num_columns_half_block = 0
    else:
        num_columns_half_block = 3

    
    total_columns = num_columns_full_blocks + num_columns_half_block

    
    hessian_matrix = np.zeros((number_of_coordinates, total_columns))
    block_width = 6


    for i in range(num_full_blocks):
        for row in range(number_of_coordinates):
            hessian_matrix[row, i * block_width:(i + 1) * block_width] = data_blocks[i * number_of_coordinates + row]

    if num_columns_half_block == 3:
        half_block_start_index = num_full_blocks * number_of_coordinates
        for row in range(number_of_coordinates):
            hessian_matrix[row, num_columns_full_blocks:num_columns_full_blocks + num_columns_half_block] = data_blocks[half_block_start_index + row]
    np.savetxt(output_filename, hessian_matrix, delimiter=",", fmt="%.6f")
    

def parse_and_save_hessian(input_filename, output_filename):
    ###skips headers and indices, constructs a matrix, and saves as a CSV
    num_of_atoms = number_of_atoms(input_filename)
    number_of_coordinates = num_of_atoms*3
    full_block = number_of_coordinates/6
    num_full_blocks = math.floor(full_block)
    full_block_width = 6
    if full_block == num_full_blocks: #no half block
        half_block_width = 0
    else:
        half_block_width = 3
    total_columns = num_full_blocks * full_block_width + half_block_width
    final_matrix = np.zeros((number_of_coordinates, total_columns))

    start_reading = False
    current_block_row_count = 0
    current_row = 0
    current_col = 0
    block_counter = 0

    found_hessian = False
    with open(input_filename, 'r') as infile:
        for line in infile:
            line = line.strip()
            if "Final Hessian." in line:
                start_reading = True
                found_hessian = True
                continue
            
            if start_reading and line:
                if current_block_row_count % (number_of_coordinates + 1) == 0:
                    current_block_row_count += 1
                    continue  #skip the header row of each block
            
                entries = line.split()[1:]  #skip the first column indicies
                if entries:
                    block_width = full_block_width if block_counter < num_full_blocks else half_block_width

                    for i, value in enumerate(entries):
                        try:
                            if i < block_width:
                                final_matrix[current_row, current_col + i] = float(value)
                        except ValueError:
                            print(f"Error at block {block_counter+1}, row {current_row+1}, column {i+1}: '{value}' not a float")
                            continue

                current_row += 1
                if current_row >= number_of_coordinates:
                    current_row = 0
                    current_col += block_width
                    block_counter += 1
                    if block_counter > num_full_blocks:
                        break
                current_block_row_count += 1
        
        if not found_hessian:
            sys.exit("Final Hessian matrix not found in the output.")
                
    np.savetxt(output_filename, final_matrix, delimiter=",", fmt="%.7f")

if __name__ == "__main__":
    options, args = ParseInput(sys.argv)
    target_dir = args[1]
    
    files = glob.glob(os.path.join(target_dir, '*.out'))
    if not files:
        raise FileNotFoundError("No output files found in the target directory.")
    if len(files) > 1:
        raise RuntimeError("More than ONE output files found in the target directory.")
    input_filename = files[0]
    
    output_csv_filename1 = f"{target_dir}/QChem_projected_Hessian.csv"
    output_csv_filename = f"{target_dir}/QChem_final_Hessian.csv"

    parse_and_save_hessian(input_filename,output_csv_filename)
    print(f"Final Hessian matrix saved to '{output_csv_filename}'")

    parse_and_save_projected_hessian(input_filename, output_csv_filename1)
    print(f"Projected mass-weighted Hessian matrix saved to '{output_csv_filename1}'")
